# Parsing

### 1. Parser
They take input(tokens, strings etc) and produce AST.  
  
  
```javascript
> var input = '{"name": "Thorsten", "age": 28}';
> var output = JSON.parse(input);
> output
{ name: 'Thorsten', age: 28 }
```
The above is a JS json parser taking string as input and producing a datastructure representing the input.  
The `abstract` in AST is based on the fact that certain details visible in the source code are omitted in the AST eg semicolons, newlines, whitespace etc  

Parsers take source code as input (either as text or tokens) and produce a data structure which represents this source code.  
While creating that data structure, they also analyse the input, checking that it conforms to the expected structure.   
Thus the process of parsing is also called `syntactic analysis`. That is where you get the famous; `parseError`  

We'll create a parser for khaled, it's input will be the tokens produced by the [lexer](2.Lexing.md)  
We'll also define our own AST, suited to khaled.  

### 2. Parser generators
These are tools that, when fed with a formal description of a language, produce
parsers as their output.  
Examples are; yacc, bison or ANTLR.  
The majority use a context-free grammar (CFG) as their input. Examples of CFGs are the
Backus-Naur Form (BNF) or the Extended Backus-Naur Form (EBNF).  
Parsers are well suited to being automatically generated, and you should use a parser generator if you can.  
We wont use a parser generator, however.

### 3. khaled parser
There are 2 main parsing techniques top-down parsing or bottom-up parsing(with various variations in there.)   
The parser we are going to write is a recursive descent parser. And in particular, itâ€™s a "top
down operator precedence" parser, sometimes called "Pratt parser".

### 3.1 Parsing let statements
```bash
let x = 5;
let foobar = add(5, 5);
```
We need to parse(produce AST) for `let` statements. They are of the form;
```bash
let <identifier> = <expression>;
```
where identifier and expression can change.  
Statement do not produce values, expresssions produce values: (this differs from one lang to the other)
`let x=5` doesnt produce value, `5` does. `return 5` is a statement, `add(5,5)` is an expression.  

We thus need two types of Nodes; a `Statement node` and an `Expression node`

```bash
let x = 5; 
```
can be represented by an AST like;
```bash
					*ast.Program
					Statements
						|
					*ast.LetStatement   
                         *ast.Identifier <-  Name
					     Value --> *ast.Expression
```  
